##[[
EMSCRIPTEN = true
if EMSCRIPTEN then
  config.cc = 'emcc'
  cflags '-ffast-math -fno-plt -flto --llvm-lto 1 --closure 1'
  cflags "-DGRAPHICS_API_OPENGL_ES2 -Oz -s USE_GLFW=3 -s ASSERTIONS=1 -s WASM=1 -s TOTAL_MEMORY=16777216"
  cinclude '<emscripten.h>'
  primtypes.integer = primtypes.int32
  primtypes.uinteger = primtypes.uint32
end
]]

require 'raylib'
require 'math'
require 'string'
require 'vector'

-- Compile time constants
local SCREEN_WIDTH <comptime> = 600
local SCREEN_HEIGH <comptime> = 800
local TILEMAP_WIDTH <comptime> = 512
local TILEMAP_OFFSET: Vector2 = {
  (SCREEN_WIDTH - TILEMAP_WIDTH) // 2,
  SCREEN_HEIGH - TILEMAP_WIDTH - (SCREEN_WIDTH - TILEMAP_WIDTH) // 2
}
local TILE_SPACING <comptime> = 12
local TILE_COUNT <comptime> = 4
local TILE_WIDTH <comptime> = (TILEMAP_WIDTH - (TILE_COUNT+1)*TILE_SPACING) // TILE_COUNT
local NEWBUTTON_RECT: Rectangle = {SCREEN_WIDTH - 128 - 44, 48 + 128, 128, 48}

local frametime = Raylib.GetTime()

-- Timer
local Timer = @record { started: number, duration: number }
function Timer:elapsed(): number
  return frametime - self.started
end
function Timer:delay(delay: number)
  self.started = self.started + delay
end
function Timer:progress(): number
  if self.duration == 0 then return 1.0 end
  return math.min(self:elapsed() / self.duration, 1.0)
end
function Timer:finished(): boolean
  if self.duration == 0 then return false end
  return (frametime - self.started) >= self.duration
end
function Timer:restart()
  self.started = frametime
end
function Timer.create(duration: number): Timer
  return Timer{frametime, duration}
end
function Timer.create_delayed(duration: number, delay: number): Timer
  return Timer{frametime + delay, duration}
end

-- TileAnim
local TileAnimKind = @enum { NONE=0, MOVE, RAISE, MERGE}
local TileAnim = @record {
  kind: TileAnimKind,
  n: integer,
  timer: Timer,
  movepos: Vector2
}
function TileAnim.createMove(n: integer, duration: number, movepos: Vector2): TileAnim
  return TileAnim{kind = TileAnimKind.MOVE, n=n, timer=Timer.create(duration), movepos = movepos}
end
function TileAnim.createRaise(n: integer, duration: number): TileAnim
  return TileAnim{kind = TileAnimKind.RAISE, n=n, timer=Timer.create(duration)}
end
function TileAnim.createMerge(n: integer, duration: number, delay: number): TileAnim
  return TileAnim{kind = TileAnimKind.MERGE, n=n, timer=Timer.create_delayed(duration, delay)}
end

-- Game variables
local TileMap = @integer[TILE_COUNT][TILE_COUNT]
local tiles: TileMap
local AnimTileMap = @vector(TileAnim)[TILE_COUNT][TILE_COUNT]
local tileanims: AnimTileMap
local statetimer: Timer
local score: integer
local GameState = @enum{ IDLE=0, SPAWNING, SLIDING }
local gamestate: GameState
local notify: record{text:string, timer:Timer}

local function set_game_state(state: GameState, duration: number)
  gamestate = state
  statetimer = Timer.create(duration)
end

local function clear_animations()
  tileanims = (@AnimTileMap){}
end

local function get_random_avaiable_tile(): (integer, integer)
  local availables: record{x: integer, y: integer}[(TILE_COUNT*TILE_COUNT)]
  local index = 0
  for x=0,TILE_COUNT-1 do
    for y=0,TILE_COUNT-1 do
      if tiles[x][y] == 0 then
        availables[index] = {x, y}
        index = index + 1
      end
    end
  end
  if index == 0 then return -1, -1 end
  index = math.random(0, index-1)
  return availables[index].x, availables[index].y
end

local function spawn_tile()
  local SPAWN_DURATION <comptime> = 0.1
  local x, y = get_random_avaiable_tile()
  if x == -1 then return end
  tiles[x][y] = 1
  if gamestate ~= GameState.SPAWNING then
    set_game_state(GameState.SPAWNING, SPAWN_DURATION)
  end
  tileanims[x][y]:push(TileAnim.createRaise(1, SPAWN_DURATION))
end

local function reset_game()
  tiles = (@TileMap)()
  tileanims = (@AnimTileMap)()
  score = 0
  notify = {}
  statetimer = {}
  gamestate = GameState.IDLE
  spawn_tile()
  spawn_tile()
end

local function slide_tiles(keydir: integer)
  local SLIDE_DURATION <comptime> = 0.1
  local MERGE_DURATION <comptime> = 0.2
  local slidden = false
  local addscore = 0
  clear_animations()

  ## function macro_process_tile()
    local n = tiles[x][y]
    local movepos: Vector2 = {x, y}
    tileanims[x][y]:push(TileAnim.createMove(n, SLIDE_DURATION, movepos))
    if n > 0 then
      local nn = n
      if ln == n then
        nn = n + 1
        addscore = addscore + (1 << nn)
        ln = 0
      else
        ln = n
        lx = lx + lxs
        ly = ly + lys
      end
      if y ~= ly or x ~= lx then
        tileanims[x][y][0].movepos = {lx, ly}
        tiles[x][y] = 0
        tiles[lx][ly] = nn
        if n ~= nn then
          tileanims[lx][ly]:push(TileAnim.createMerge(nn, MERGE_DURATION, SLIDE_DURATION))
        end
        slidden = true
      end
    end
  ## end

  if keydir == KeyboardKey.UP then
    local lxs, lys = 0, 1
    for x=0,TILE_COUNT-1,1 do
      local lx, ly, ln = x, -1, 0
      for y=0,TILE_COUNT-1,1 do
        ## macro_process_tile()
      end
    end
  elseif keydir == KeyboardKey.DOWN then
    local lxs, lys = 0, -1
    for x=0,TILE_COUNT-1 do
      local lx, ly, ln = x, TILE_COUNT, 0
      for y=TILE_COUNT-1,0,-1 do
        ## macro_process_tile()
      end
    end
  elseif keydir == KeyboardKey.LEFT then
    local lxs, lys = 1, 0
    for y=0,TILE_COUNT-1 do
      local lx, ly, ln = -1, y, 0
      for x=0,TILE_COUNT-1,1 do
        ## macro_process_tile()
      end
    end
  elseif keydir == KeyboardKey.RIGHT then
    local lxs, lys = -1, 0
    for y=0,TILE_COUNT-1 do
      local lx, ly, ln = TILE_COUNT, y, 0
      for x=TILE_COUNT-1,0,-1 do
        ## macro_process_tile()
      end
    end
  end

  if slidden then
    set_game_state(GameState.SLIDING, SLIDE_DURATION)
  else
    clear_animations()
  end

  if addscore > 0 then
    score = score + addscore
    notify = {'+' .. tostring(addscore), Timer.create(1.0)}
  end
end

local function get_tile_rect(x: number, y: number): Rectangle
  return (@Rectangle){
    TILEMAP_OFFSET.x + (x+1)*TILE_SPACING + x*TILE_WIDTH,
    TILEMAP_OFFSET.y + (y+1)*TILE_SPACING + y*TILE_WIDTH,
    TILE_WIDTH, TILE_WIDTH}
end

local function draw_boxed_text(text: string, rect: Rectangle, fontsize: integer, fgcolor: Color)
  if #text == 0 then return end
  local font = Raylib.GetFontDefault()
  local spacing = math.ceil(fontsize / 20)
  local textsize = Raylib.MeasureTextEx(font, text, fontsize, spacing)
  local pos: Vector2 = { rect.x + (rect.width - textsize.x) // 2,
                         rect.y + (rect.height - textsize.y) // 2 }
  Raylib.DrawTextEx(font, text, pos, fontsize, spacing, fgcolor)
end

local function draw_tiles_grid()
  local bgrect: Rectangle = { TILEMAP_OFFSET.x, TILEMAP_OFFSET.y, TILEMAP_WIDTH, TILEMAP_WIDTH }
  Raylib.DrawRectangleRec(bgrect, Raylib.GetColor(0xBBADA0FF))
  for i=0,TILE_COUNT-1 do
    for j=0,TILE_COUNT-1 do
      Raylib.DrawRectangleRec(get_tile_rect(i, j), Raylib.GetColor(0xCDC1B4FF))
    end
  end
end

local TILE_COLORS: record{fg: Color, bg: Color}[10] = {
  {fg=Raylib.GetColor(0x776E65FF), bg=Raylib.GetColor(0xEEE4DAFF)}, -- 2
  {fg=Raylib.GetColor(0x776E65FF), bg=Raylib.GetColor(0xEDE0C8FF)}, -- 4
  {fg=Raylib.GetColor(0xFFFFFFFF), bg=Raylib.GetColor(0xF59563FF)}, -- 16
  {fg=Raylib.GetColor(0xFFFFFFFF), bg=Raylib.GetColor(0xF67C5FFF)}, -- 32
  {fg=Raylib.GetColor(0xFFFFFFFF), bg=Raylib.GetColor(0xF65E3BFF)}, -- 64
  {fg=Raylib.GetColor(0xFFFFFFFF), bg=Raylib.GetColor(0xEDCF72FF)}, -- 128
  {fg=Raylib.GetColor(0xFFFFFFFF), bg=Raylib.GetColor(0xEDCC61FF)}, -- 256
  {fg=Raylib.GetColor(0xFFFFFFFF), bg=Raylib.GetColor(0xEDC850FF)}, -- 512
  {fg=Raylib.GetColor(0xFFFFFFFF), bg=Raylib.GetColor(0xDDB513FF)}, -- 1024
  {fg=Raylib.GetColor(0xFFFFFFFF), bg=Raylib.GetColor(0xEDC22EFF)}  -- 2048
}

local function scale_rect(rect: Rectangle, scale: number): Rectangle
  local newrect: Rectangle
  newrect.width = rect.width * scale
  newrect.height = rect.height * scale
  newrect.x = rect.x + (rect.width - newrect.width) / 2
  newrect.y = rect.y + (rect.height - newrect.height) / 2
  return newrect
end

local function draw_tile(x: number, y: number, num: integer, scale: number, opacity: number)
  if num == 0 then return end
  local color = TILE_COLORS[(num-1) % #TILE_COLORS]
  local rect = scale_rect(get_tile_rect(x, y), scale)
  local fontsize = (@integer)(math.ceil(8*scale))*5
  Raylib.DrawRectangleRec(rect, Raylib.Fade(color.bg, opacity))
  draw_boxed_text(tostring(1 << num), rect, fontsize, Raylib.Fade(color.fg, opacity))
end

local function ease_in_back(x: number): number
  return (1.70158+1)*x*x*x - 1.70158*x*x
end
local function ease_out_back(x: number): number
  return 1-ease_in_back(1-x)
end

local function draw_tiles()
  for x=0,TILE_COUNT-1 do
    for y=0,TILE_COUNT-1 do
      local opacity = 1
      local scale = 1
      local pos: Vector2 = {x, y}
      local num = tiles[x][y]
      local animcount = #tileanims[x][y]
      if animcount > 0 then
        for i=0,animcount-1 do
          local anim = &tileanims[x][y][i]
          if not anim.timer:finished() then
            num = anim.n
            local fact = anim.timer:progress()
            if anim.kind == TileAnimKind.MOVE then
              pos = pos*(1-fact) + anim.movepos * fact
            elseif anim.kind == TileAnimKind.RAISE then
              opacity = fact*fact
            elseif anim.kind == TileAnimKind.MERGE then
              scale = ease_out_back(fact)
            end
            break
          end
        end
      end
      draw_tile(pos.x, pos.y, num, scale, opacity)
    end
  end
end

local function draw_title()
  draw_boxed_text('2048', {44, 44, 200, 128}, 80, Raylib.GetColor(0x776E65FF))
end

local function draw_score()
  local rect: Rectangle = {SCREEN_WIDTH - 128 - 44, 48, 128, 96}
  local titlerect: Rectangle = {rect.x, rect.y + 8, rect.width, 20}
  local textrect: Rectangle = {rect.x, rect.y + 8, rect.width, rect.height}
  Raylib.DrawRectangleRec(rect, Raylib.GetColor(0xBBADA0FF))
  draw_boxed_text('Score', titlerect, 20, Raylib.GetColor(0xEEE4DAFF))
  draw_boxed_text(tostring(score), textrect, 40, RaylibColors.Raywhite)
end

local function draw_buttons()
  Raylib.DrawRectangleRec(NEWBUTTON_RECT, Raylib.GetColor(0x8F7A66FF))
  draw_boxed_text('New Game', NEWBUTTON_RECT, 20, RaylibColors.Raywhite)
end

local function draw_notifications()
  if notify.timer:finished() then return end
  local f = notify.timer:progress()
  local opacity = 1 - f*f
  local rect: Rectangle = {SCREEN_WIDTH//2, 128 - f * 128, 128, 96}
  draw_boxed_text(notify.text, rect, 60, Raylib.Fade(RaylibColors.Black, opacity))
end

local function draw()
  Raylib.BeginDrawing()
  Raylib.ClearBackground(Raylib.GetColor(0xFAF8EFFF))
  draw_tiles_grid()
  draw_tiles()
  draw_title()
  draw_score()
  draw_buttons()
  draw_notifications()
  Raylib.EndDrawing()
end

local function check_slide()
  if gamestate == GameState.SLIDING then return end
  if Raylib.IsKeyPressed(KeyboardKey.UP) then
    slide_tiles(KeyboardKey.UP)
  elseif Raylib.IsKeyPressed(KeyboardKey.DOWN) then
    slide_tiles(KeyboardKey.DOWN)
  elseif Raylib.IsKeyPressed(KeyboardKey.LEFT) then
    slide_tiles(KeyboardKey.LEFT)
  elseif Raylib.IsKeyPressed(KeyboardKey.RIGHT) then
    slide_tiles(KeyboardKey.RIGHT)
  end
end

local function check_newgame()
  if Raylib.IsMouseButtonPressed(MouseButton.LEFT_BUTTON) and
     Raylib.CheckCollisionPointRec(Raylib.GetMousePosition(), NEWBUTTON_RECT) then
    reset_game()
  end
end

local function update()
  frametime = Raylib.GetTime()
  check_slide()
  check_newgame()

  if statetimer:finished() then
    switch gamestate
    case GameState.SLIDING then
      spawn_tile()
    case GameState.SPAWNING then
      clear_animations()
      set_game_state(GameState.IDLE, 0)
    end
  end
end

local function frame() <codename 'frame'>
  update()
  draw()
  gc:run()
end

local function init()
  gc:pause()
  Raylib.SetTargetFPS(60)
  Raylib.InitWindow(SCREEN_WIDTH, SCREEN_HEIGH, "2048 Game")
  reset_game()
end

local function run()
  repeat
    ## if EMSCRIPTEN then
    ## cemit 'emscripten_set_main_loop(frame, 0, 1);'
    ## else
      frame()
    ## end
  until Raylib.WindowShouldClose()
end

local function terminate()
  Raylib.CloseWindow()
end

init()
run()
terminate()
